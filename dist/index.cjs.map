{"version":3,"sources":["../src/index.ts","../src/canUseDOM.ts","../src/formatString.ts","../src/createFieldOptions.ts","../src/createQueryString.ts","../src/getPayloadReference.ts","../src/getUrl.ts","../src/object.ts","../src/parseSearchParams.ts","../src/slugify.ts","../src/urlEncoding.ts"],"sourcesContent":["export * from './canUseDOM.js'\nexport * from './createFieldOptions.js'\nexport * from './createQueryString.js'\nexport * from './formatString.js'\nexport * from './getPayloadReference.js'\nexport * from './getUrl.js'\nexport * from './object.js'\nexport * from './parseSearchParams.js'\nexport * from './slugify.js'\nexport * from './urlEncoding.js'\n","export const canUseDOM = !!(\n  typeof window !== 'undefined' &&\n  window.document &&\n  window.document.createElement\n)\n","export const capitalize = (str: string = ''): string => {\n  if (!str.length) {\n    return ''\n  }\n\n  return str.charAt(0).toUpperCase() + str.slice(1)\n}\n","import { capitalize } from './formatString.js'\n\n// Define a utility type to extract the keys from a union type\ntype ExtractKeys<T> = T extends string ? T : never\n\n// Create a generic function to create the record and options based on the type\nexport const createFieldOptions = <T extends string>(keys: ExtractKeys<T>[]) => {\n  const values = keys.reduce(\n    (acc, key) => {\n      acc[key] = key\n      return acc\n    },\n    {} as Record<ExtractKeys<T>, string>,\n  )\n\n  const options = keys.map((key) => ({\n    label: capitalize(key),\n    value: key,\n  }))\n\n  return { values, options }\n}\n","import * as qs from 'qs-esm'\n\nexport const createQueryString = (query: any): string => {\n  return qs.stringify(query, { addQueryPrefix: true })\n}\n","export function getPayloadReference<T>(ref: T | string | null | undefined) {\n  if (typeof ref === 'string') {\n    return null\n  }\n\n  return ref as T\n}\n","import { canUseDOM } from './canUseDOM.js'\n\nexport const getServerSideURL = () => {\n  let url = process.env.NEXT_PUBLIC_SERVER_URL\n\n  if (!url && process.env.VERCEL_PROJECT_PRODUCTION_URL) {\n    return `https://${process.env.VERCEL_PROJECT_PRODUCTION_URL}`\n  }\n\n  if (!url) {\n    url = 'http://localhost:3000'\n  }\n\n  return url\n}\n\nexport const getClientSideURL = () => {\n  if (canUseDOM) {\n    const protocol = window.location.protocol\n    const domain = window.location.hostname\n    const port = window.location.port\n\n    return `${protocol}//${domain}${port ? `:${port}` : ''}`\n  }\n\n  if (process.env.VERCEL_PROJECT_PRODUCTION_URL) {\n    return `https://${process.env.VERCEL_PROJECT_PRODUCTION_URL}`\n  }\n\n  return process.env.NEXT_PUBLIC_SERVER_URL || ''\n}\n","// @ts-nocheck\n\n// Utility type to extract keys that are strings from a union type\ntype ExtractKeys<T> = Extract<T, string>\n\n/**\n * Get a deeply nested property of an object based on a dot-separated path.\n * @param obj - The object to traverse.\n * @param path - Dot-separated string representing the path to the property.\n * @returns The value at the specified path or undefined if the path does not exist.\n */\nexport const getNestedProperty = (obj: Record<string, unknown>, path: string): any => {\n  return path\n    .split('.') // Split the path into individual keys\n    .reduce(\n      (acc, key) => (acc && typeof acc === 'object' && key in acc ? acc[key] : undefined),\n      obj,\n    ) // Traverse the object based on the keys\n}\n\n/**\n * Checks if the given item is a plain object (not an array, null, or primitive).\n * @param item - The item to check.\n * @returns True if the item is an object, otherwise false.\n */\nexport function isObject(item: unknown): boolean {\n  return item !== null && typeof item === 'object' && !Array.isArray(item)\n}\n\n/**\n * Performs a deep merge of two objects.\n * If both properties are objects, they are recursively merged.\n * Primitive values in the source object overwrite those in the target object.\n * @param target - The object to be updated.\n * @param source - The object to merge into the target.\n * @returns The merged object.\n */\nexport function deepMerge<T, R>(target: T, source: R): T & R {\n  const output = { ...target } as T & R // Create a shallow copy of the target\n  if (isObject(target) && isObject(source)) {\n    Object.keys(source).forEach((key) => {\n      const sourceValue = (source as Record<string, unknown>)[key]\n      if (isObject(sourceValue)) {\n        // If the source value is an object, recursively merge\n        if (!(key in target)) {\n          Object.assign(output, { [key]: sourceValue }) // Copy source value if not in target\n        } else {\n          output[key] = deepMerge((target as Record<string, unknown>)[key], sourceValue)\n        }\n      } else {\n        // Overwrite with primitive values from source\n        Object.assign(output, { [key]: sourceValue })\n      }\n    })\n  }\n  return output\n}\n\n/**\n * Creates an object where each key maps to its own name as a string.\n * @param keys - Array of keys to create the object from.\n * @returns An object where each key is assigned its own name as the value.\n */\nexport const createObjectKeys = <T extends string>(keys: ExtractKeys<T>[]): Record<T, string> => {\n  return keys.reduce(\n    (acc, key) => {\n      acc[key] = key // Assign the key to itself as the value\n      return acc\n    },\n    {} as Record<T, string>,\n  )\n}\n","import type { ReadonlyURLSearchParams } from 'next/navigation.js'\n\nimport * as qs from 'qs-esm'\n\n/**\n * A utility function to parse URLSearchParams into a ParsedQs object.\n * This function is a wrapper around the `qs` library.\n * In Next.js, the `useSearchParams()` hook from `next/navigation` returns a `URLSearchParams` object.\n * This function can be used to parse that object into a more usable format.\n * @param {ReadonlyURLSearchParams} searchParams - The URLSearchParams object to parse.\n * @returns {qs.ParsedQs} - The parsed query string object.\n */\nexport function parseSearchParams(searchParams: ReadonlyURLSearchParams): qs.ParsedQs {\n  const search = searchParams.toString()\n\n  return qs.parse(search, {\n    depth: 10,\n    ignoreQueryPrefix: true,\n  })\n}\n","/**\n * Hack to make 'slugify' import work with \"type\": \"module\".\n */\nimport * as s from 'slugify'\n\n// Fallback for CommonJS or ESM default export\nexport const slugify = s.default || s\n","/**\n * Decodes an array of URL-encoded strings.\n *\n * @param url - An array of URL-encoded strings.\n * @returns An array of decoded strings where each URL-encoded string is transformed into its decoded form.\n *\n * @example\n * // Decoding an array of URL-encoded strings\n * decodeUrl([\"Hello%20World\", \"How%27s%20it%20going\"]);\n * // Output: [\"Hello World\", \"How's it going\"]\n */\nexport const decodeUrl = (url: string[]): string[] => {\n  // Use the map function to iterate over each string in the array\n  // and apply the decodeURIComponent function to decode the string.\n  return url.map((s) => decodeURIComponent(s))\n}\n\n/**\n * Encodes a single string for use in a URL.\n *\n * @param url - A string to be URL-encoded.\n * @returns A URL-encoded version of the input string.\n *\n * @example\n * // Encoding a string for use in a URL\n * encodeUrl(\"Hello World\");\n * // Output: \"Hello%20World\"\n */\nexport const encodeUrl = (url: string): string => {\n  // Encode a single string\n  return encodeURIComponent(url)\n}\n"],"mappings":"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","names":["qs","s"]}